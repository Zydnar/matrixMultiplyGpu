<html>
<head>
<title>falling sand gpgpu</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<link type="text/css" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/themes/ui-lightness/jquery-ui.css" rel="stylesheet"/>
<script type="text/javascript" src="static/sylvester.js"></script>
<script type="text/javascript" src="static/glUtils.js"></script>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.js"></script>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.7.2/jquery-ui.js"></script>

<script id="simple-vs" type="x-shader/x-vertex">

  uniform mat4 uMVMatrix; 
  attribute vec4 aPosition;
  uniform vec4 color; 
  void main() {
     gl_Position = uMVMatrix * aPosition;
  }
</script>

<script id="simple-fs" type="x-shader/x-fragment">
  uniform vec4 color; 
  void main() {
      gl_FragColor = color;
  }
</script>

<script id="shader-fs" type="x-shader/x-fragment">
  varying vec2 vTextureCoord;

  uniform sampler2D src;
  uniform sampler2D rand;
  uniform float randomOffset;
  uniform float canvasWidth;
  uniform float canvasHeight;

  float unPackValue(in vec3 bytes){
       bytes = bytes * vec3(255.0, 255.0, 255.0);
       return (bytes.x * 65536.0)  + (bytes.y * 256.0) + bytes.z;
  }

  vec3 packValue(in float value){

      vec3 ret = vec3(0.0, 0.3, 0.0);

      int totalBytes = 3;
      float radixMax = 0.0;
      int place = 0;
      for(int i = totalBytes; i > 0; --i){
	radixMax = pow(256.0, float(i - 1));
        place = (totalBytes - i);
	if(value >= radixMax){
          ret[place] = floor(value / radixMax);
          value = mod(value, radixMax);
	}
      }


     return (ret   / vec3(255.0, 255.0, 255.0));

  return ret;
// / 
//  
//             mod(value, 65535.0)  / 256.0, 
  }

  void main(void)
  {
    float pixelWidth =  1.0 / canvasWidth;
    float pixelHeight =  1.0 / canvasHeight;
    vec3 bottomSand = vec3(0.5, 0.5, 0.5);
    vec3 topSand = vec3(0.6, 0.6, 0.6);
    vec4 current = texture2D(src, vTextureCoord);

    vec3 outputVec = vec3(0.0, 0.0, 0.0);
//    vec4 above = texture2D(src, getAboveTexCoord(vTextureCoord, pixelWidth, pixelHeight));

  float resultValue = 0.0;
    for(float i = 0.0; i < float(canvasWidth); ++i){
    	float valueOne = 0.0; 
    	valueOne = unPackValue(texture2D(src, vec2( (i * pixelWidth), vTextureCoord.t)).xyz);
    	float valueTwo = 0.0;
    	valueTwo = unPackValue(texture2D(rand, vec2(vTextureCoord.s, (i * pixelHeight))).xyz);
	resultValue += valueOne *  valueTwo;		   
    }
    outputVec.xyz = packValue(resultValue);
    gl_FragColor = vec4(outputVec,  1.0);


  }


</script>

<script id="shader-vs" type="x-shader/x-vertex">


  attribute vec3 aVertexPosition;
  attribute vec2 aTextureCoord;
/*
  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
*/
  varying vec2 vTextureCoord;


  void main(void)
  {
    gl_Position = vec4(aVertexPosition, 1.0);
    vTextureCoord = aTextureCoord;
  }
</script>


<script type="application/x-javascript">

  // This code is for Firefox/Minefield compatibility.  WebGL
  // originally used a class called CanvasFloatArray, but the
  // specification has now changed, and it's called WebGLFloatArray.
  // Firefox/Minefield still (as of 13 Nov 2009) uses the old
  // name, but WebKit/Safari uses the new one.  The main WebGL
  // code in this page uses the new name, but the compatibility
  // code that follows will stay here for the time being to make
  // sure that Firefox users can view the page.
  try
  {
    WebGLFloatArray;
  }
  catch (e)
  {
    try
    {
      WebGLArrayBuffer = CanvasArrayBuffer;
      WebGLByteArray = CanvasByteArray;
      WebGLUnsignedByteArray = CanvasUnsignedByteArray;
      WebGLShortArray = CanvasShortArray;
      WebGLUnsignedShortArray = CanvasUnsignedShortArray;
      WebGLIntArray = CanvasIntArray;
      WebGLUnsignedIntArray = CanvasUnsignedIntArray;
      WebGLFloatArray = CanvasFloatArray;
    }
    catch (e)
    {
      alert("Could not find Canvas array types for WebGL.");
    }
  }
  // End of compatibility code


  var gl;
  canvasWidth = 600;
  canvasHeight = 600;

  function initGL()
  {
    var canvas = document.getElementById("canvas");

    try
    {
      gl = canvas.getContext("webkit-3d");
    }
    catch(e)
    {
    }
    if (!gl)
    {
      try
      {
        gl = canvas.getContext("moz-webgl");
      }
      catch(e)
      {
      }
    }
    if (!gl)
    {


      $("body").html("\
            <span>WebGL is required, below are instructinons to enable WebGL for Safari and Firefox</span><br/>\
            <a href='http://webkit.org/blog/603/webgl-now-available-in-webkit-nightlies/'>webkit WebGL instructions</a><br/>\
            <a href='http://learningwebgl.com/blog/?p=11#install-firefox'>firefox WebGL instructions</a>");
      throw "no WebGL";
      alert("Could not initialise WebGL, sorry :-(");
    }

    // This temporary code provides support for Google Chrome, which
    // as of 30 Nov 2009 does not support the new names for the
    // functions to get shader/program parameters (among other things).
    // It should be unnecessary soon, and is only a partial fix
    // in the meantime (as, for example, there's no way to get shader
    // or program parameters that are vectors of integers).
    // See http://learningwebgl.com/blog/?p=1082 for details.
    if (!gl.getProgramParameter)
    {
      gl.getProgramParameter = gl.getProgrami
    }
    if (!gl.getShaderParameter)
    {
      gl.getShaderParameter = gl.getShaderi
    }
    // End of Chrome compatibility code

  }


  function getShader(gl, id)
  {
      var shaderScript = document.getElementById(id);
      if (!shaderScript)
          return null;

      var str = "";
      var k = shaderScript.firstChild;
      while (k)
      {
          if (k.nodeType == 3)
              str += k.textContent;
          k = k.nextSibling;
      }

      var shader;
      if (shaderScript.type == "x-shader/x-fragment")
      {
          shader = gl.createShader(gl.FRAGMENT_SHADER);
      }
      else if (shaderScript.type == "x-shader/x-vertex")
      {
          shader = gl.createShader(gl.VERTEX_SHADER);
      }
      else
      {
          return null;
      }

      gl.shaderSource(shader, str);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
      {
          alert(gl.getShaderInfoLog(shader));
          return null;
      }

      return shader;
  }


  var simpleShaderProgram;
  var shaderProgram;
  var vertexPositionAttribute;
  var textureCoordAttribute;
  function initShaders()
  {
    var fragmentShader = getShader(gl, "shader-fs");
    var vertexShader = getShader(gl, "shader-vs");

    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
    {
      alert("Could not initialise shaders");
    }

    gl.useProgram(shaderProgram);

    vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(vertexPositionAttribute);

    textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
    gl.enableVertexAttribArray(textureCoordAttribute);


    var simpleFragmentShader = getShader(gl, "simple-fs");
    var simpleVertexShader = getShader(gl, "simple-vs");

    simpleShaderProgram = gl.createProgram();
    gl.attachShader(simpleShaderProgram, simpleVertexShader);
    gl.attachShader(simpleShaderProgram, simpleFragmentShader);
    gl.linkProgram(simpleShaderProgram);

    gl.useProgram(simpleShaderProgram);

    aPositionAttribute = gl.getAttribLocation(simpleShaderProgram, "aPosition");
    gl.enableVertexAttribArray(aPositionAttribute);

    if (!gl.getProgramParameter(simpleShaderProgram, gl.LINK_STATUS))
    {
      alert("Could not initialise simple shaders");
    }

    gl.useProgram(shaderProgram);

  }


  function handleLoadedTexture(image, texture, clamp)
  {
    gl.enable(gl.TEXTURE_2D);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    if(clamp){
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    gl.bindTexture(gl.TEXTURE_2D, null);
  }


  var neheTexture;
  var neheTexture2;
  var neheImage;
  var globalFbo;
  var globalFbo2;
  function initTexture()
  {
    neheTexture = gl.createTexture();
    neheImage = document.createElement("canvas");
    neheImage.width = canvasWidth;
    neheImage.height = canvasHeight;
    var ctx = neheImage.getContext("2d")

    var imgData = ctx.getImageData(0,0, ctx.canvas.width, ctx.canvas.height)
    for(i = 0; i < imgData.data.length; i+=4){
        imgData.data[i + 0] = 0;
        imgData.data[i + 1] = 0; 
        imgData.data[i + 2] = 8;
        imgData.data[i + 3] = 255;
    }
    ctx.putImageData(imgData, 0, 0);


//    neheImage.onload = function()
//    {
      handleLoadedTexture(neheImage, neheTexture, true)
//    }

//    neheImage.src = "http://learningwebgl.com/lessons/lesson05/nehe.gif";

    neheTexture2 = gl.createTexture();
    neheImage2 = document.createElement("canvas");
    neheImage2.width = canvasWidth;
    neheImage2.height = canvasHeight;

    var ctx2 = neheImage2.getContext("2d")
    var imgData = ctx2.getImageData(0,0, ctx2.canvas.width, ctx2.canvas.height)
    for(var i = 0; i < ctx.canvas.height; ++i){
	var offset = i * ctx.canvas.width * 4;
	var widthCounter = 0;
    	for(var k = 0; k < ctx.canvas.width * 4; k+=4){
	    if(widthCounter % 2 == 0)
    	        {imgData.data[offset + k + 0] = 0; imgData.data[offset + k + 1] = 0;  imgData.data[offset + k + 2] = 1; imgData.data[offset + k + 3] = 255;}
	    if(widthCounter % 2 == 1)
    	        {imgData.data[offset + k + 0] = 0; imgData.data[offset + k + 1] = 0;  imgData.data[offset + k + 2] = 2; imgData.data[offset + k + 3] = 255;}
	    ++widthCounter;
    	}
    }
    ctx2.putImageData(imgData, 0, 0);



//    neheImage2.onload = function()
//    {
      handleLoadedTexture(neheImage2, neheTexture2, true)
//    }

//    neheImage2.src = "http://learningwebgl.com/lessons/lesson05/nehe.gif";

  }


  var mvMatrix;
  var mvMatrixStack = [];

  function mvPushMatrix(m) {
    if (m) {
      mvMatrixStack.push(m.dup());
      mvMatrix = m.dup();
    } else {
      mvMatrixStack.push(mvMatrix.dup());
    }
  }

  function mvPopMatrix() {
    if (mvMatrixStack.length == 0)
      throw "Invalid popMatrix!";
    mvMatrix = mvMatrixStack.pop();
    return mvMatrix;
  }

  function loadIdentity()
  {
    mvMatrix = Matrix.I(4);
  }


  function multMatrix(m)
  {
    mvMatrix = mvMatrix.x(m);
  }

  function mvTranslate(v, m)
  {
    var m = Matrix.Translation($V([v[0], v[1], v[2]])).ensure4x4();
    return m.flatten();
  }

  function mvRotate(ang, v)
  {
    var arad = ang * Math.PI / 180.0;
    var m = Matrix.Rotation(arad, $V([v[0], v[1], v[2]])).ensure4x4();
    multMatrix(m);
  }

  var pMatrix;
  function perspective(fovy, aspect, znear, zfar)
  {
    pMatrix = makePerspective(fovy, aspect, znear, zfar)
  }


  function setMatrixUniforms(matrix)
  {
  //  var pUniform = gl.getUniformLocation(simpleShaderProgram, "uPMatrix");
//    gl.uniformMatrix4fv(pUniform, false, new WebGLFloatArray(pMatrix.flatten()));

    var mvUniform = gl.getUniformLocation(simpleShaderProgram, "uMVMatrix");
    gl.uniformMatrix4fv(mvUniform, false, new WebGLFloatArray(matrix));
  }
  function setColorUniforms(color)
  {
    var colorUniform = gl.getUniformLocation(simpleShaderProgram, "color");
    gl.uniform4f(colorUniform, color[0], color[1], color[2], color[3]);
  }
  function setRandomUniforms(random, randomTexture)
  {
    var randomUniform = gl.getUniformLocation(shaderProgram, "randomOffset");
    gl.uniform1f(randomUniform, random);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, randomTexture);
    gl.uniform1i(gl.getUniformLocation(shaderProgram, "rand"), 1);

  }


  var penPolygonBuffer;

  var cubeVertexPositionBuffer;
  var cubeVertexTextureCoordBuffer;
  var cubeVertexIndexBuffer; 
  var penPolygonIndexBuffer; 
  function initBuffers()
  {
//pen polygon buffer


         var penPolygonVertices = [
        0.5,  0.5,  0.0,
        -0.5,  0.5,  0.0,
         0.5, -0.5,  0.0,
        -0.5, -0.5,  0.0

];
/*
                     -0.5,  1.0, 0.0,
                    -1.0, 0.0, 0.0,
                     0.0, 0.0, 0.0,
                   0.5, 1.0, 0.0,


*/


        penPolygonBuffer= gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, penPolygonBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, new WebGLFloatArray(penPolygonVertices), gl.STATIC_DRAW);
	gl.bindBuffer(gl.ARRAY_BUFFER, null);
        penPolygonBuffer.itemSize = 3;
        penPolygonBuffer.numItems = 4;


//polygon buffer






    cubeVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
    vertices = [
      // Front face
      -1.0, -1.0,  0.0,
       1.0, -1.0,  0.0,
       1.0,  1.0,  0.0,
      -1.0,  1.0,  0.0
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new WebGLFloatArray(vertices), gl.STATIC_DRAW);
    cubeVertexPositionBuffer.itemSize = 3;
    cubeVertexPositionBuffer.numItems = 4;

    cubeVertexTextureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
    var textureCoords = [
      // Front face
      0.0, 0.0,
      1.0, 0.0,
      1.0, 1.0,
      0.0, 1.0,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new WebGLFloatArray(textureCoords), gl.STATIC_DRAW);
    cubeVertexTextureCoordBuffer.itemSize = 2;
    cubeVertexTextureCoordBuffer.numItems = 4;

    cubeVertexIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
    var cubeVertexIndices = [
      0, 1, 2,      0, 2, 3,    // Front face
    ]
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new WebGLUnsignedShortArray(cubeVertexIndices), gl.STATIC_DRAW);
    cubeVertexIndexBuffer.itemSize = 1;
    cubeVertexIndexBuffer.numItems = 6;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);



    penPolygonIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, penPolygonIndexBuffer);
    var penPolygonVertexIndices = [
      0, 1, 2, 3     // Front face
    ]
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new WebGLUnsignedShortArray(penPolygonVertexIndices), gl.STATIC_DRAW);
    penPolygonIndexBuffer.itemSize = 1;
    penPolygonIndexBuffer.numItems =  4;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);


  globalRenderBufferId = gl.createRenderbuffer();
  gl.bindRenderbuffer(gl.RENDERBUFFER, globalRenderBufferId);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT, canvasWidth, canvasHeight);
  gl.isRenderbuffer(globalRenderBufferId);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);


  globalFbo = gl.createFramebuffer();
  gl.bindFramebuffer( gl.FRAMEBUFFER, globalFbo);
  gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, neheTexture, 0);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, globalRenderBufferId);
  gl.bindFramebuffer( gl.FRAMEBUFFER, null);


  globalRenderBufferId2 = gl.createRenderbuffer();
  gl.bindRenderbuffer(gl.RENDERBUFFER, globalRenderBufferId2);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT, canvasWidth, canvasHeight);
  gl.isRenderbuffer(globalRenderBufferId2);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);


  globalFbo2 = gl.createFramebuffer();
  gl.bindFramebuffer( gl.FRAMEBUFFER, globalFbo2);
  gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, neheTexture2, 0);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, globalRenderBufferId2);
  gl.bindFramebuffer( gl.FRAMEBUFFER, null);
  var fboStatus = gl.checkFramebufferStatus( gl.FRAMEBUFFER);


  }

  var xRot = 0;
  var yRot = 0;
  var zRot = 0;
  var everyOther = true;

  function drawScene(drawPen, penColor, randomTexture)
  {
   
    var random = parseInt(Math.random() * 200);
//    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

    if(everyOther == true)
      gl.bindFramebuffer(gl.FRAMEBUFFER, globalFbo)
    else
      gl.bindFramebuffer(gl.FRAMEBUFFER, globalFbo2)

    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
    gl.vertexAttribPointer(vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
    gl.vertexAttribPointer(textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.activeTexture(gl.TEXTURE0);
    if(everyOther == true)
      gl.bindTexture(gl.TEXTURE_2D, neheTexture2);
    else
      gl.bindTexture(gl.TEXTURE_2D, neheTexture);

    gl.uniform1i(gl.getUniformLocation(shaderProgram, "src"), 0);
    setRandomUniforms(random, randomTexture)
    gl.uniform1f(gl.getUniformLocation(shaderProgram, "canvasWidth"), canvasWidth);
    gl.uniform1f(gl.getUniformLocation(shaderProgram, "canvasHeight"), canvasHeight);

 

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);



    	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    	gl.bindTexture(gl.TEXTURE_2D, null);
    	gl.bindBuffer(gl.ARRAY_BUFFER, null);


    	gl.useProgram(simpleShaderProgram);
    	gl.bindBuffer(gl.ARRAY_BUFFER, penPolygonBuffer);
    	gl.vertexAttribPointer(aPositionAttribute, penPolygonBuffer.itemSize, gl.FLOAT, false, 0, 0);
    	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, penPolygonIndexBuffer);
/*
        setMatrixUniforms([1.0, 0.0, 0.0, 0.0, 
                           0.0, 1.0, 0.0, 0.0, 
                           0.0, 0.0,   1, 0.0, 
                           drawPen.x, -drawPen.y,   0.0, 1.0]);
*/

/*
    if(drawPen){
        matrix = mvTranslate([ drawPen.scale * (drawPen.x -1.0) , drawPen.scale * (-drawPen.y + 1.0), 1.0], [1.0, 0.0, 0.0, 0.0, 
                           0.0, 1.0, 0.0, 0.0, 
                           0.0, 0.0,   1, 0.0, 
                           0.0, 0.0,   0.0, 1.0]);
        matrix[15] = drawPen.scale

        setMatrixUniforms(matrix);
        setColorUniforms(penColor);

    	gl.drawElements(gl.TRIANGLE_STRIP, penPolygonIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }

    //begin draw oil sprinkler
        matrix = mvTranslate([ 20.0 , 30.0, 1.0], [1.0, 0.0, 0.0, 0.0, 
                           0.0, 1.0, 0.0, 0.0, 
                           0.0, 0.0,   1, 0.0, 
                           0.0, 0.0,   0.0, 1.0]);
        matrix[15] = 30.0;
        setMatrixUniforms(matrix);
        setColorUniforms([0.5, 0.25, 0.25, 1.0]);
        gl.drawElements(gl.TRIANGLE_STRIP, penPolygonIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    //end draw oil sprinkler


    //begin draw black sprinkler
        matrix = mvTranslate([ -20.0 , 30.0, 1.0], [1.0, 0.0, 0.0, 0.0, 
                           0.0, 1.0, 0.0, 0.0, 
                           0.0, 0.0,   1, 0.0, 
                           0.0, 0.0,   0.0, 1.0]);
        matrix[15] = 30.0;
        setMatrixUniforms(matrix);
        setColorUniforms([0.0, 0.0, 0.0, 1.0]);
        gl.drawElements(gl.TRIANGLE_STRIP, penPolygonIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    //end draw black sprinkler
*/
    	gl.useProgram(shaderProgram);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

/*
//    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
    gl.vertexAttribPointer(vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
    gl.vertexAttribPointer(textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.activeTexture(gl.TEXTURE0);
    if(everyOther == true)
      gl.bindTexture(gl.TEXTURE_2D, neheTexture2);
    else
      gl.bindTexture(gl.TEXTURE_2D, neheTexture);

    gl.uniform1i(gl.getUniformLocation(shaderProgram, "src"), 0);
    setRandomUniforms(random, randomTexture);
    gl.uniform1f(gl.getUniformLocation(shaderProgram, "canvasWidth"), canvasWidth);
    gl.uniform1f(gl.getUniformLocation(shaderProgram, "canvasHeight"), canvasHeight);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

*/
    everyOther = !(everyOther)
  

  }


  var lastTime = 0;
  function animate()
  {
    var timeNow = new Date().getTime();
    if (lastTime != 0)
    {
      var elapsed = timeNow - lastTime;

      xRot += (90 * elapsed) / 1000.0;
      yRot += (90 * elapsed) / 1000.0;
      zRot += (90 * elapsed) / 1000.0;
    }
    lastTime = timeNow;
  }



  var pixels = null;
  var penColor = [1.0, 1.0, 1.0, 1.0];
  function webGLStart()
  {
    initGL();
    initShaders();

    var startDate = new Date();
    initTexture();

    gl.clearColor(1.0, 1.0, 1.0, 1.0);
    gl.disable(gl.DEPTH_TEST)        

/*
    gl.clearDepth(1.0);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
*/

    initBuffers();


  var randomCanvas = createRandomCanvas(canvasWidth, canvasHeight)
  var randomTexture = gl.createTexture();
  handleLoadedTexture(randomCanvas, randomTexture)
  var drawPen = null;
  var tickNumber = 0;		  
  function tick(){
     drawScene(drawPen, penColor, randomTexture);
     gl.bindFramebuffer( gl.FRAMEBUFFER, globalFbo);
     pixels = gl.readPixels(0, 0, canvasWidth, canvasHeight, gl.RGBA, gl.UNSIGNED_BYTE);
     gl.bindFramebuffer( gl.FRAMEBUFFER, null);

			   if(tickNumber < 3)
         alert((new Date() - startDate) / 1000.0);

     ++tickNumber;
  }
  setTimeout(tick, 0);  




  canvas = $("#canvas");
  canvas.mousedown(function(e){ 
      canvas.mousemove(function(e){
          drawPen = { scale: 0.2 * Math.pow(($("#penSizeSlider").slider('option', 'max') + 1) - $("#penSizeSlider").slider('option', 'value') ,2 ) + 1.0};
//          drawPen = { scale: 100.0};
          drawPen.x = (e.pageX - canvas.offset().left) / (canvas.width() /2);
          drawPen.y = (e.pageY - canvas.offset().top ) / (canvas.height() /2);
      });
  });
  $("#canvas").mouseup(function(){canvas.mousemove(function(){drawPen = null;}); drawPen = null;});

/*
canvas.mousedown();
canvas.mousemove();
//canvas.mouseup();
*/  
  }

 $(document).ready(function(){
    $(".blueWater").click(function(){ penColor = [0.0, 0.0, 1.0, 1.0] });
    $(".blackLiquid").click(function(){ penColor = [0.0, 0.0, 0.0, 1.0] })
    $(".fire").click(function(){ penColor = [1.0, 0.0, 0.0, 1.0]})
    $(".wall").click(function(){penColor = [0.55, 0.55, 0.55, 1.0] })
    $(".sandBrown").click(function(){ penColor = [0.5, 0.25, 0.25, 1.0]; })
    $(".white").click(function(){ penColor = [1.0, 1.0, 1.0, 1.0]})
    $(".plant").click(function(){ penColor = [0.0, 1.0, 0.0, 1.0]})
    $("#penSizeSlider").slider({orientation: 'vertical', max : 10, min: 1});

    var width = gup('width');
    var height = gup('height');
    if((!width || !height)){
        width = 500;
        height = 500;
    }
    
    $("body").prepend("<canvas id='canvas' width='" + width + "' height='" + height + "'></canvas>");
    
    canvasWidth = width;
    canvasHeight = height;
    $("#randomImage").get(0).onload = webGLStart;

  

  });


  function createRandomCanvas(width, height){

    var randomImage = document.getElementById("randomImage");
    var randomCanvas = document.createElement("canvas");

    randomCanvas.width = canvasWidth;
    randomCanvas.height = canvasHeight;
    var ctx = randomCanvas.getContext("2d");

    var imgData = ctx.getImageData(0,0, ctx.canvas.width, ctx.canvas.height)
    for(var i = 0; i < ctx.canvas.height; ++i){
	var offset = i * ctx.canvas.width * 4;
	var widthCounter = 0;
    	for(var k = 0; k < ctx.canvas.width * 4; k+=4){
	    if(widthCounter % 2 == 0)
    	        {imgData.data[offset + k + 0] = 0; imgData.data[offset + k + 1] = 0;  imgData.data[offset + k + 2] = 1; imgData.data[offset + k + 3] = 255;}
	    if(widthCounter % 2 == 1)
    	        {imgData.data[offset + k + 0] = 0; imgData.data[offset + k + 1] = 0;  imgData.data[offset + k + 2] = 2; imgData.data[offset + k + 3] = 255;}
	    ++widthCounter;
    	}
    }


    ctx.putImageData(imgData, 0, 0);

$("body").append(randomCanvas);
    return randomCanvas;
  }

function gup( name )
{
  name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
  var regexS = "[\\?&]"+name+"=([^&#]*)";
  var regex = new RegExp( regexS );
  var results = regex.exec( window.location.href );
  if( results == null )
    return null;
  else
    return results[1];
}
</script>

<style>
  #canvas{float:left; border: 1px solid black;}
  .colorSelection{height: 58px; border: 2px solid black; position:absolute; bottom: 11px;}
  .colorSelection div { margin-top:2px; margin-bottom:2px; margin-right:4px; margin-left:4px; height: 50px; float: left; border: 1px solid black;  width: 50px; color:white; text-align:center;
      border: 2px solid; 
      border-color: #aaa #000 #000 #aaa; 
  }

  .colorSelection div:hover { 
      position: relative; 
      top: 1px; 
      left: 1px; 
      border-color: #000 #aaa #aaa #000; 
  }


  .blueWater {background-color:blue;}
  .blackLiquid {background-color:black;}
  .fire {background-color:red;}
  .wall {background-color:grey;}
  .white {background-color:white; color: black !important;}
  .plant {background-color:green;}
  .sandBrown {background-color:brown;}

  #penSizeSliderContainer{margin: 8px; float:left; position:relative; height: 50%; top:0%;    }
  #penSizeSlider{height: 100%; margin-left: auto; margin-right:auto;}
  #penSizeSliderBottom{ }
  #penSizeSliderTop{position:relative; margin-left: auto; margin-right:auto; text-align:center;  }
  #canvasSizeSelect{ font-size: small; position:absolute; bottom: 74px;}

  
</style>
</head>


<body>
  <img id="randomImage" style="display:none;" src="static/randomImage.png" />
  <br/>
  <div id="penSizeSliderContainer">
    <div id="penSizeSliderTop">+</div>
    <div id="penSizeSlider"></div><br/>
    <div id="penSizeSliderBottom">Brush Size</div>
  </div><br/>
  <div id="canvasSizeSelect">
    <a  href="index.html?width=200&height=200">small</a>
    <a  href="index.html?width=500&height=500">medium</a>
    <a  href="index.html?width=800&height=800">big</a>
    <a  href="index.html?width=1024&height=1024">super</a>
  </div> 
  
  <div class="colorSelection">
      <div class="blueWater">Water</div> 
      <div class="blackLiquid">Black Liquid</div> 
      <div class="fire">Fire</div>
      <div class="wall">Wall</div> 
      <div class="plant">Plant</div> 
      <div class="white">White</div> 
      <div class="sandBrown">Oil</div> 
  </div>

<span style="font-size:x-small; position:absolute; bottom:0px; left: 440px"><a href="mailto:aaron.babcock@gmail.com">aaron.babcock@gmail.com</a></span>



</body>
</html>
