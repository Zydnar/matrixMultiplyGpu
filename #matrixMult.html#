<html>
<head>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.js"></script>
<script type="text/javascript" src="static/sylvester.js"></script>
<script id="matrixMult"  type="x-shader/x-fragment">
  varying vec2 vTextureCoord;

  uniform sampler2D src;
  uniform sampler2D rand;
  uniform float randomOffset;
  uniform float canvasWidth;
  uniform float canvasHeight;

  float unPackValue(in vec3 bytes){
       bytes = bytes * vec3(255.0, 255.0, 255.0);
       return (bytes.x * 65536.0)  + (bytes.y * 256.0) + bytes.z;
  }

  vec3 packValue(in float value){

      vec3 ret = vec3(0.0, 0.3, 0.0);
      int totalBytes = 3;
      float radixMax = 0.0;
      int place = 0;
      for(int i = totalBytes; i > 0; --i){
	radixMax = pow(256.0, float(i - 1));
        place = (totalBytes - i);
	if(value >= radixMax){
          ret[place] = floor(value / radixMax);
          value = mod(value, radixMax);
	}
      }

     return (ret   / vec3(255.0, 255.0, 255.0));

  }

  void main(void)
  {
    float pixelWidth =  1.0 / canvasWidth;
    float pixelHeight =  1.0 / canvasHeight;
    vec3 bottomSand = vec3(0.5, 0.5, 0.5);
    vec3 topSand = vec3(0.6, 0.6, 0.6);
    vec4 current = texture2D(src, vTextureCoord);

    vec3 outputVec = vec3(0.0, 0.0, 0.0);

  float resultValue = 0.0;
    for(float i = 0.0; i < float(canvasWidth); ++i){
    	float valueOne = 0.0; 
    	valueOne = unPackValue(texture2D(src, vec2( (i * pixelWidth), vTextureCoord.t)).xyz);
    	float valueTwo = 0.0;
    	valueTwo = unPackValue(texture2D(rand, vec2(vTextureCoord.s, (i * pixelHeight))).xyz);
	resultValue += valueOne *  valueTwo;		   
    }
    outputVec.xyz = packValue(resultValue);
    gl_FragColor = vec4(outputVec,  1.0);

  }

</script>

<script id="textureCordVertexShader" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  attribute vec2 aTextureCoord;
  varying vec2 vTextureCoord;
  void main(void)
  {
    gl_Position = vec4(aVertexPosition, 1.0);
    vTextureCoord = aTextureCoord;
  }
</script>
<script>
function createFramebuffer(texture, canvasWidth, canvasHeight){

  globalRenderBufferId = gl.createRenderbuffer();
  gl.bindRenderbuffer(gl.RENDERBUFFER, globalRenderBufferId);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT, canvasWidth, canvasHeight);
  gl.isRenderbuffer(globalRenderBufferId);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);


  globalFbo = gl.createFramebuffer();
  gl.bindFramebuffer( gl.FRAMEBUFFER, globalFbo);
  gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, globalRenderBufferId);
  gl.bindFramebuffer( gl.FRAMEBUFFER, null);

  return globalFbo
}

function createBuffers(){
    buffers = {};

    cubeVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
    vertices = [
      // Front face
      -1.0, -1.0,  0.0,
       1.0, -1.0,  0.0,
       1.0,  1.0,  0.0,
      -1.0,  1.0,  0.0
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new WebGLFloatArray(vertices), gl.STATIC_DRAW);
    cubeVertexPositionBuffer.itemSize = 3;
    cubeVertexPositionBuffer.numItems = 4;
    buffers.cubeVertexPositionBuffer = cubeVertexPositionBuffer;



    cubeVertexTextureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
    var textureCoords = [
      // Front face
      0.0, 0.0,
      1.0, 0.0,
      1.0, 1.0,
      0.0, 1.0,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new WebGLFloatArray(textureCoords), gl.STATIC_DRAW);
    cubeVertexTextureCoordBuffer.itemSize = 2;
    cubeVertexTextureCoordBuffer.numItems = 4;
    buffers.cubeVertexTextureCoordBuffer = cubeVertexTextureCoordBuffer;


    cubeVertexIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
    var cubeVertexIndices = [
      0, 1, 2,      0, 2, 3,    // Front face
    ]
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new WebGLUnsignedShortArray(cubeVertexIndices), gl.STATIC_DRAW);
    cubeVertexIndexBuffer.itemSize = 1;
    cubeVertexIndexBuffer.numItems = 6;
    buffers.cubeVertexIndexBuffer = cubeVertexIndexBuffer;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);


   return buffers;
}


function createTexture(canvas){
  var texture = gl.createTexture();
  gl.enable(gl.TEXTURE_2D);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, canvas);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return texture;

}

function createCanvas(width, height){

  var randomCanvas = document.createElement("canvas");

  return randomCanvas;
}

function calculateFrame(shaderProgram, textureOne, textureTwo, buffers, framebuffer, canvasWidth, canvasHeight){
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer)

    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.cubeVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, buffers.cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.cubeVertexTextureCoordBuffer);
    gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, buffers.cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, textureOne);
    gl.uniform1i(shaderProgram.srcUniformLoc, 0);
    gl.uniform1f(shaderProgram.randomUniform, 1);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, textureTwo);
    gl.uniform1i(shaderProgram.randLoc, 1);

    gl.uniform1f(shaderProgram.canvasWidthLoc, canvasWidth);
    gl.uniform1f(shaderProgram.canvasHeightLoc, canvasHeight);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.cubeVertexIndexBuffer);
    gl.drawElements(gl.TRIANGLES, buffers.cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

var gl = null;
$(document).ready(function(){
  canvasWidth = 3000;
  canvasHeight = 3000;
  var canvas =  document.createElement("canvas");
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;


  try{
    gl = canvas.getContext("webkit-3d");
  } catch(e){
      try{
          gl = canvas.getContext("moz-webgl");
      } catch(e){
          $("body").html("\
            <span>WebGL is required, below are instructinons to enable WebGL for Safari and Firefox</span><br/>\
            <a href='http://webkit.org/blog/603/webgl-now-available-in-webkit-nightlies/'>webkit WebGL instructions</a><br/>\
            <a href='http://learningwebgl.com/blog/?p=11#install-firefox'>firefox WebGL instructions</a>");
          throw "no WebGL";
      }
  }

//compile shaders  
  var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragShader, $("#matrixMult").html());
  gl.compileShader(fragShader);
  if(!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS))
      throw gl.getShaderInfoLog(fragShader);


  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, $("#textureCordVertexShader").html());
  gl.compileShader(vertexShader);
  if(!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))
      throw gl.getShaderInfoLog(vertexShader);
//end compile shaders              

//init shader program
  var shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragShader);
  gl.linkProgram(shaderProgram);
  gl.useProgram(shaderProgram);

  shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
  gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
  shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
  gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

  shaderProgram.srcUniformLoc = gl.getUniformLocation(shaderProgram, "src");
  shaderProgram.randomUniformLoc = gl.getUniformLocation(shaderProgram, "randomOffset");
  shaderProgram.randLoc =  gl.getUniformLocation(shaderProgram, "rand");
  shaderProgram.canvasWidthLoc = gl.getUniformLocation(shaderProgram, "canvasWidth");
  shaderProgram.canvasHeightLoc = gl.getUniformLocation(shaderProgram, "canvasHeight");
//end shader program


  gl.clearColor(1.0, 1.0, 1.0, 1.0);
  gl.disable(gl.DEPTH_TEST)        

  buffers = createBuffers();
  framebuffer = createFramebuffer(createTexture(createCanvas(canvasWidth, canvasHeight)), canvasWidth, canvasHeight);

  var textureOne = createTexture(createCanvas(canvasWidth, canvasHeight));
  var textureTwo = createTexture(createCanvas(canvasWidth, canvasHeight));



  var startDate = new Date();
  var tickNumber = 0;
  function tick(){
     calculateFrame(shaderProgram, textureOne, textureTwo, buffers, framebuffer, canvasWidth, canvasHeight);
     gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer);
     pixels = gl.readPixels(0, 0, canvasWidth, canvasHeight, gl.RGBA, gl.UNSIGNED_BYTE);
     gl.bindFramebuffer( gl.FRAMEBUFFER, null);

     if(tickNumber < 1)
         setTimeout(tick, 0);
     else
         alert((new Date() - startDate) / 1000.0);
     ++tickNumber;
  }
  setTimeout(tick, 0);

  
})
</script>




<title>Matrix Multiply GPU</title>
</head>
<body>

</body>
</html>

